1) Data.sql Schema.sql використовується лише для реляційних баз даних (для нереляційних немає такої зручної
мови sql)
    Аналогом для створення генераторів початкових даних можуть бути біни для створення функціональних інтерфейсів
     CommandLineRunner, ApplicationRunner,  оскільки можуть за допомогою @Autowired
     отримувати репозиторії в метод run (Книга Spring ст. ~110)

2) В використанні Spring Data jdbc щоб позначити сутність використовується анотація @Table (інформація десь в районі
     100 сторінки книги Spring)

3) При автоматичному генеруванні репозиторіїв при використнні Spring Data jdbc (ст. 120):
 Всі власні методи запитів вимагають наявності анотації @Query. Це тому, що, на відміну від JPA, у
Spring Data JDBC немає метаданих мапування, які допомагали б автоматично вивести запит з імені методу.
 Усі запити, вказані в анотації @Query, повинні бути SQL-запитами, а не запитами JPA.

4) В  книжці також було сказано про нереляційну базу даних Cassandra (4 глава ~120 ст.). Основне:
  База даних отримана була із Docker
  В ній присутні кластерні та роздільні ключі які позначаються в сутнстях - @PrimaryKeyColumn(type=PrimaryKeyType.CLUSTERED,
                                                                              ordering=Ordering.DESCENDING),@PrimaryKeyColumn(type=PrimaryKeyType.PARTITIONED)
 2 види ключів представляють собою первинний ключ де партійний ключ представляє розділ в якому знаходяться дані (якщо однакове значення, то дані будуть
в одному розділі) і кластерний, що представляє собою значення за яким відбувається сортування (Якщо вас не цікавить порядок, то властивість id
просто анотована як @PrimaryKey, позначаючає її як роздільний ключ і ключ кластеризації з типовим порядком.)
 також в касандрі дані представляються в дуже денормалізованому стані тобто значення із однієї сімї (таблиці) можуть бути і в іншій
 при створенні сутності ми позначаємо обєкт @Table("tacos")
 при створенні колекції в сутності можуть використовуватись лише колекції примітивних типів чи користувацьких (тих над якими опреділено
анотацію @UserDefinedType("ingredient")) ст.128
 для одного обєкта не може бути одночасно @Table та @UserDefinedType

5) Для java є декілька вбудованих баз даних (H2,Mongo) для цього потрібно добавити їх залежність в pom.xml (Mongo - ст.134, H2 - ст.92)
Важливо відзначити, що це рішення призначене для тестування та розробки і може бути менш ефективним для великих обсягів даних або продуктивного використання.

6) spring.sql.init.mode=always - вказує щоб spring завжди виконував скрипти sql (якщо не помиляюсь при встроєній бд цього робити не потрібно)

7) При використанні Spring Data MongoDB в доменному класі (класі сутності) @Id повинна бути над типом що реалізує
Serializable

8) В <form> thymeleaf можна написати шлях th:action (якщо не писати, то запит буде відправлено на той же шлях на якому
представлено форму) тут можна вказати @{...} і якщо ми напишемо:
           a) @{orders} то це буде продовження шляху на якому було відкрито сторінку;
           б) @{/orders} це буде абсолютний шлях
????? то що написано вище правда, но коли я підключив spring security це перестало працювати (скоріше за все
при його ввімкнені нам обовязкво потрібно вказувати th:action)

9) Якщо метод позначено анотацією     @ModelAttribute(name = "taco") то цей метод буде викликатись перед кожним запитом,
приклад - Коли ви відправляєте POST-запит на обробку, перед викликом методу, позначеного анотацією @PostMapping, спочатку
буде викликаний метод, позначений @ModelAttribute, щоб підготувати об'єкт Taco.

10) Порядок правил позначених в HttpSecurity має значення. Правила безпеки, визначені першими, мають вищий пріоритет
над тими,  що визначені нижче. Якщо ви поміняєте порядок цих двох правил безпеки, всі запити будуть мати
permitAll() застосовано до них; правило для запитів /design і /orders не матиме ефекту. (ст. 153)

11) Якщо я створюю бін SecurityFilterChain то мені обовязково треба буде зробити formLogin інакше при невдачі доступу
не буде переходу до сторінки аутентифікації (якщо потім не вказати сторінку loginPage то Spring створить її автоматично
на шляху /login)

12) Якщо в формі <form> є  хочаб 1 параметр з th: то CSRF токен буде створюватись автоматично

13) Якщо потрібно отримати інформацію про аутентифікованого юзера то - ст.164 (Spring in Action)

14) Є деяка особливість в налаштуванні бінів коли ми хочемо передати якісь параметри. Дані можуть братись із різних
джерел, таких як системні властивості JVM, змінні середовища операційної системи, аргументи командного рядка
та конфігураційні файли властивостей додатку. Як це працює в часі:
   a) Запуск додатку: При запуску додатку Spring Boot використовує всі ці джерела властивостей для збору конфігураційних параметрів.
   b) Створення Spring Environment: Spring створює об'єкт оточення (Environment), який агрегує (збирає і об'єднує всі доступні
   конфігураційні властивості з різних джерел у єдиний) всі конфігураційні властивості.
   c) Внедрення властивостей в біни: Коли Spring створює біни в додатку, властивості можна внедрювати безпосередньо
в код бінів через анотації, такі як @Value або @ConfigurationProperties.

15) при використанні мого mykeys.jks при переході на сайт з https:// я отримаю помилку оскільки сертифікат
сгенерований автоматично не є зареєстрований в центрах сертифікації (без встановлення параметрів ssl в доступі
до сайту з https:// буде просто відмовлено)

16) Якщо потрібно налаштувати logback власноручно то ст.173 в книжці Spring in Action (фрагмент
<logger name="root" level="INFO"/> відповідає за налаштування логування для відповідного классу який вказаний замість
"root")

17) Можна використовувати @Profile на методі позначеному @Bean якщо потрібно дозволити його використання лише в
певних профілях (також можна використати анотації @Nullable @Autowired(required = false) для того щоб один
бін міг завантажуватись як нульовий)

18) Коли ми використовуємо @GetMapping(params = "recent") то даний метод буде приймати лише ті запити
в якиє є даний параметер. Щоб дати можливість роботи без нього потрібно не вказувати там params та в анотації
@RequestParam встановити (required = false)

19) Якщо при використанні jdbc нам потрібно отримати id (коли значення identity тощо) значення
що ми записуємо то використовується GeneratedKeyHolder (ст. - 103)


20) Коли ви використовуєте @CrossOrigin над методом або класом контролера, ви дозволяєте запити від клієнта, що приходять
з інших доменів, оброблятися вашим контролером. (запити з інших доменів будуть ігноруватись даним контролером)


21)     @PostMapping(consumes="application/json"), @RequestBody User user прийме любий json де є хочаб один рядок і
спробує звязати по назвах полів. У разі помилок валідації буде викинуто помилку, но якщо їх немає (налаштувань валідації), то
метод може містити абсолютно пустий обєкт


22) Тобто Remote Address це адреса на яку ми відправляємо повідомлення яка вже потім зєднується з Local Address нашого брокера?
    Якщо це так то чому ми не можемо зразу на Local Address брокера відправляти повідомлення?
Так, ви правильно зрозуміли. Remote Address це адреса, на яку ваш додаток відправляє повідомлення, і це з'єднання встановлюється
з сервером JMS або брокером повідомлень. Коли це з'єднання встановлене, воно потім з'єднується з Local Address на сервері,
де відбувається обробка повідомлення.
Щодо вашого другого питання, чому ми не можемо відправляти повідомлення безпосередньо на Local Address брокера: це через
те, що брокер повідомлень зазвичай працює у режимі очікування на з'єднання з клієнтами. Коли ваш додаток відправляє
повідомлення, воно не може просто надіслати його на Local Address брокера, оскільки це потребує з'єднання з сервером
брокера. Таким чином, ваш додаток повинен спочатку встановити з'єднання з сервером брокера (це Remote Address), а потім
через це з'єднання відправити повідомлення на Local Address для подальшої обробки брокером повідомлень. Така архітектура
дозволяє брокерові керувати вхідними з'єднаннями і ефективно обробляти повідомлення. (?)

23) Ця інформація не точна (????) но якщо я правильно розумію @ModelAttribute ставиться лише на той параметр методу який не передається
прямо  в <form>. Сама ж анотація @ModelAttribute бере значення з моделі для детальнішої інф див. (9).


24) При використанні rabbitMQ (для приймання повідомлення ст. 260+-) можна використати <T> T receiveAndConvert(ParameterizedTypeReference<T> type)
однак конвертером повідомлення повинна бути реалізація SmartMessageConverter (одна з яких Jackson2JsonMessageConverter)

25) Метод відправлення повідомлення в Kafka ListenableFuture<SendResult<K, V>> send(Message<?> message); всередині
перетворює Message<?> message на класс ProducerRecord в якому вже зберігається інформація про тему, розділ і тд.

26) За допомогою анотації @AliasFor, наприклад:
@AliasFor(annotation = RequestMapping.class, attribute = "method")
Можна вказати що ми хочемо налаштувати параметр мета-анотації (анотації над нашою):
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@RequestMapping
@interface MyMapping {
    @AliasFor(annotation = RequestMapping.class, attribute = "method")
    RequestMethod[] action() default {};
}
Но слід пам'ятати що в такому випадку значення параметра в RequestMapping буде нульовим і не зміниться. Но spring буде наш
параметр action сприймати як параметр method анотації @RequestMapping (написав максимально просто)

27) Коли ми використовуємо якийсь вид Channel in Spring Integration, наприклад:
IntegrationFlow.from(MessageChannels.direct("textInChannel"))
              .....
Треба бути дуже обережним з тим як працюють потоки при різних каналах:
Direct - працює в тому ж потоці що й програма;
Queue - кожен канал має свій власний потік (якщо ми одночасно відправимо пару повідомлення на один обробник то він буде
по черзі їх обробляти)
Rendezvous - тут я не до кінця зрозумів, має свій потік, но замість queue, яке просто записує їх в чергу і потім обробляє,
основний потік блокується, коли викликаємо збереження повідомлення повторно, не зачекавши кінця минулого. Також
я помітив, що останнє відправлення повідомлення опрацьовується лише при закінченні програми

28) Можна використовувати конвертери по типу
@Component
public class IngredientByIdConverter implements Converter<String, Ingredients>
коли у нас в thymeleaf є
<input th:field="*{ingredientsList}" type="checkbox"
                            th:value="${ingredient.id}">
Тут по суті ingredient.id представляє строку а не сам обєкт інгрідієнта (якщо не помиляюсь змінювати на ${ingredient} також не допоможе, оскільки буде
сприйматись як текст) тому ми повинні передавати в конвертер нашу строку і перетворювати на тип інгрідієнта


29) При використанні @Router за допомогою конфігурації java тобто коли ми повертаємо класс AbstractMessageRouter
то маємо можливість повернути масив каналів. Кожен канал буде працювати віддільно від іншого і опрацьовувати дані повідомлення по своєму.
(шукай в пошуку "тестив роботу AbstractMessageRouter")
Вивід такої програми в текст був таким що вивівся і текст оброблений трансформером 1 і текст трансформером 2
"TransOne
 TransTwo"

30) Коли я використовую анотацію @Splitter в spring integration то можу передати біном (ст. 285) створений мною класс. Якщо я правильно зрозумів,
коли це тестив, то можна створювати любий метод, но щоб тип який метод приймає був унікальним на весь класс інакше буде помилка. (шукати DataSplitter)

31) Використання MessageHandler та GenericHandler - перший не повертає параметру, а значить є кінцевим. Другий повертає параметр а значить можна продовжити
роботу з даними і передати їх в інший канал (ст. 289). Якщо ви виберете використання GenericHandler в кінці потоку, вам потрібно буде повернути null, інакше
ви отримаєте помилки, які вказують на те, що не вказано жодного вихідного каналу

32) При використанні java configuration для spring integration біни для каналів будуть створюватись автоматично, но лише ті які є в параметрі
inputChannel.
Також коли я використовую java DSL для spring integration і вказую channel, то бін каналу може створюватись або не створюватись автоматично, залежно від ситуації:
1) Канал вже був створений за допомогою inputChannel в java configuration, то якщо вкажу channel("Name") програма просто використає
створений даною конфігурацією. Однак, якщо я вкажу channel(MessageChannels.direct(Name")), то буде помилка оскільки дана команда хоче власноруч створити даний канал.
2) Каналу не було створено до даного моменту, то як при варіанті channel("Name") так і при channel(MessageChannels.direct(Name")) буде створено новий канал.

33) У разі виникнення “unknown property” в конфігурації spring - ст.295


34) spring.boot.admin.client.username=admin
    spring.boot.admin.client.password=admin -
    Ці параметри використовуються для аутентифікації клієнтського
    додатку (вашого додатку) на сервері Spring Boot Admin. Тобто, коли
    клієнтський додаток реєструється на сервері Spring Boot Admin, він
    використовує ці облікові дані для автентифікації.

    spring.boot.admin.client.instance.metadata.user.name=admin
    spring.boot.admin.client.instance.metadata.user.password=12345678 -
    Ці параметри використовуються для передачі облікових даних, які сервер
    Spring Boot Admin буде використовувати для аутентифікації на клієнтському
    додатку (вашому додатку). Тобто, коли сервер Spring Boot Admin намагається
    отримати доступ до вашого клієнтського додатку (наприклад, для отримання метрик
    або інших даних), він використовує ці облікові дані.